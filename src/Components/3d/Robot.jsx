/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.5 scene.gltf
Author: l0wpoly (https://sketchfab.com/l0wpoly)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/robot-80a736ddac1044299b134cfcca87c7f9
Title: Robot
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { current } from "@reduxjs/toolkit";

export function Robot(props) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("./assets/robot/scene.gltf");
  const faces = ["forward", "left", "backward", "right"];
  const { actions, names } = useAnimations(animations, group);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
    z: 0,
  });
  const [rotation, setRotation] = useState(0);
  const [currentAnimation, setCurrentAnimation] = useState("bob_rig|idle");
  const [isWalking, setIsWalking] = useState(false);
  const [faceIndex, setFaceIndex] = useState(0);
  const [face, setFace] = useState(faces[faceIndex]);
  const [result, setResult] = useState(null);
  const stepDistance = 0.01;

  useEffect(() => {
    setFace(faces[faceIndex]);
    if (faceIndex === 0) setRotation(2 * (Math.PI / 2));
    else if (faceIndex === 1) setRotation(3 * (Math.PI / 2));
    else if (faceIndex === 2) setRotation(0 * (Math.PI / 2));
    else if (faceIndex === 3) setRotation(1 * (Math.PI / 2));

    console.log(isWalking);
    if (isWalking) {
      actions["Take 001"].play();
    } else {
      actions["Take 001"].play();
    }
    console.log(currentAnimation);
    if (result === "win") {
      props.setCongoModal(true);
    } else if (result === "loss") {
      props.setFailModal(true);
    }
  }, [isWalking, faceIndex]);

  const levelCompleteHandler = () => {};

  const gameOverHandler = () => {};

  useFrame(() => {
    const mesh = group.current;
    let direction;

    // goal detection
    if (props.goal[0] === position.x && props.goal[1] === position.z) {
      setCurrentIndex(10);
      setResult("win");
    }

    if (currentIndex <= props.directions.length - 1) {
      setIsWalking(true);
      direction = props.directions[currentIndex];
      if (direction === "LEFT") {
        mesh.rotation.y += stepDistance;
        if (mesh.rotation.y > rotation + Math.PI / 2) {
          setCurrentIndex((prevIndex) => prevIndex + 1);
          setFaceIndex((prevIndex) => {
            if (prevIndex + 1 > 3) {
              return 0;
            }
            return prevIndex + 1;
          });
          setRotation((prevRotation) => prevRotation + Math.PI / 2);
        }
        console.log(mesh.rotation.y);
        console.log(rotation);
      } else if (direction === "RIGHT") {
        mesh.rotation.y -= stepDistance;
        if (mesh.rotation.y < rotation - Math.PI / 2) {
          setCurrentIndex((prevIndex) => prevIndex + 1);
          setFaceIndex((prevIndex) => {
            if (prevIndex - 1 < 0) {
              return 3;
            }
            return prevIndex - 1;
          });
          setRotation((prevRotation) => prevRotation - Math.PI / 2);
        }
        console.log(mesh.rotation.y);
        console.log(rotation);
      } else if (direction === "FORWARD") {
        console.log(face);
        switch (face) {
          case "forward":
            // obstacle detection
            if (
              props.obstacles.some(
                (item) => item[0] === position.x && item[1] === position.z - 1
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            // animating robot
            mesh.position.z -= stepDistance;
            if (mesh.position.z < position.z - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z - 1 });
            }
            break;
          case "left":
            if (
              props.obstacles.some(
                (item) => item[0] === position.x - 1 && item[1] === position.z
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            mesh.position.x -= stepDistance;
            if (mesh.position.x < position.x - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x - 1 });
            }
            break;
          case "backward":
            if (
              props.obstacles.some(
                (item) => item[0] === position.x && item[1] === position.z + 1
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            console.log(
              props.obstacles.some(
                (item) => item[0] === position.x && item[1] === position.z + 1
              )
            );
            mesh.position.z += stepDistance;
            if (mesh.position.z > position.z + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z + 1 });
            }
            break;
          case "right":
            if (
              props.obstacles.some(
                (item) => item[0] === position.x + 1 && item[1] === position.z
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            mesh.position.x += stepDistance;
            if (mesh.position.x > position.x + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x + 1 });
            }
            break;
        }

        console.log(mesh.position.z);
      } else if (direction === "BACKWARD") {
        console.log(face);
        switch (face) {
          case "forward":
            // obstacle detection
            if (
              props.obstacles.some(
                (item) => item[0] === position.x && item[1] === position.z + 1
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            mesh.position.z += stepDistance;
            if (mesh.position.z > position.z + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z + 1 });
            }
            break;
          case "left":
            if (
              props.obstacles.some(
                (item) => item[0] === position.x + 1 && item[1] === position.z
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            mesh.position.x += stepDistance;
            if (mesh.position.x > position.x + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x + 1 });
            }
            break;
          case "backward":
            if (
              props.obstacles.some(
                (item) => item[0] === position.x && item[1] === position.z - 1
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            mesh.position.z -= stepDistance;
            if (mesh.position.z < position.z - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z - 1 });
            }
            break;
          case "right":
            if (
              props.obstacles.some(
                (item) => item[0] === position.x - 1 && item[1] === position.z
              )
            ) {
              setResult("loss");
              setCurrentIndex(10);
            }
            mesh.position.x -= stepDistance;
            if (mesh.position.x < position.x - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x - 1 });
            }
            break;
        }
      }
    } else {
      setIsWalking(false);
    }
    // Update the object's position based on the current direction
    // console.log(position);
    // console.log(direction);
    // console.log(currentIndex);
  });

  return (
    <group
      ref={group}
      position={[0, -0.02, 0]}
      scale={0.5}
      rotation={[0, rotation, 0]}
      dispose={null}
    >
      <group name="Sketchfab_Scene">
        <group
          name="Sketchfab_model"
          rotation={[-Math.PI / 2, 0, 0]}
          scale={0.057}
        >
          <group
            name="edca9fd234644d5480a540acc91ca584fbx"
            rotation={[Math.PI / 2, 0, 0]}
          >
            <group name="Object_2">
              <group name="RootNode">
                <group name="Object_4">
                  <primitive object={nodes._rootJoint} />
                  <group
                    name="Object_6"
                    position={[0, 10, 0]}
                    rotation={[-Math.PI / 2, 0, 0]}
                  />
                  <group
                    name="Robo"
                    position={[0, 10, 0]}
                    rotation={[-Math.PI / 2, 0, 0]}
                  />
                  <group
                    name="Cylinder001"
                    position={[-0.121, 0, -0.603]}
                    rotation={[-Math.PI / 2, 0, 0]}
                  >
                    <mesh
                      name="Cylinder001_M_Suelo_0"
                      geometry={nodes.Cylinder001_M_Suelo_0.geometry}
                      material={materials.M_Suelo}
                    />
                  </group>
                  <skinnedMesh
                    name="Object_7"
                    geometry={nodes.Object_7.geometry}
                    material={materials.M_Metal1}
                    skeleton={nodes.Object_7.skeleton}
                  />
                  <skinnedMesh
                    name="Object_8"
                    geometry={nodes.Object_8.geometry}
                    material={materials.M_Pantalla1}
                    skeleton={nodes.Object_8.skeleton}
                  />
                  <skinnedMesh
                    name="Object_9"
                    geometry={nodes.Object_9.geometry}
                    material={materials.M_Pantalla2}
                    skeleton={nodes.Object_9.skeleton}
                  />
                  <skinnedMesh
                    name="Object_10"
                    geometry={nodes.Object_10.geometry}
                    material={materials.M_Rueda}
                    skeleton={nodes.Object_10.skeleton}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("./assets/robot/scene.gltf");
